/* 堆排序 */
/* 
    最好，最坏，平均复杂度均为O(nlogn),也是不稳定排序
*/

/* 
    堆： 具有以下性质的完全二叉树；每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆
    或每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆。

    大顶堆：arr[i] >= arr[2i+1] && arr[i] >= arr[2i+2]
    小顶堆：arr[i] <= arr[2i+1] && arr[i] <= arr[2i+2]  
*/

/* 
    堆排序的思路就是：将待排序的序列构成一个大顶堆，此时整个序列的最大值就是堆顶的根节点
    将其与尾元素进行交换，此时末尾为最大值。

    然后将剩余n-1个元素重新构造成一个堆，这样会得到n个元素的次小值。如此反复执行，便能得到一个有序序列了
*/

/**
 * 堆排序
 * 
 * @param {any} ary 需要排序的数组
 * @param {any} min 最小值
 * @param {any} max 最大值
 */
function HeapAdjust(l, s, m) { //使用调整大顶堆进行排序，将s到m之间的数值调整为大顶堆！
    var temp = l[s]; //将大顶堆顶值负值给temp；
    for (var j = 2 * s + 1; j < m; j = 2 * j + 1) //由于下标是0；这里只从0，1，3，5...每列的第一个数字开始便利就行
    {
        if (j < m && l[j] < l[j + 1]) //如果当前下标的值比下一个下标的数值比下一个小（我们是要找最大的那个），则就使j+1指向那个数字
            ++j;
        if (temp >= l[j]) //如果堆顶的值大于当前j下标的值，就不用再找了。跳出循环
            break;
        l[s] = l[j]; //小于j下标的值，就把l[j]复制给l[s]
        s = j; //s就指向当前j的位置，为下步把顶值赋值到这个位置做准备（循环完之前，先不赋值）
    }
    l[s] = temp; //最后赋值给l[s]（s指向现在找到的最大的大堆顶的值）
}

function HeapSort(l) {
    for (var i = l.length / 2; i >= 0; i--) //首先构造一个标准的大堆顶，只需要便利二叉树一半的节点，就能够把大堆顶构造出来
        HeapAdjust(l, i, l.length);
    for (var i = l.length; i > 0; i--) { //构造完之后 把堆顶的值和最后一个互换，然后 排除最后一个继续进行打造大堆顶！
        swap(l, 0, i - 1);
        HeapAdjust(l, 0, i - 2);
    }
}

function swap(l, i, j) {
    var temp = l[i];
    l[i] = l[j];
    l[j] = temp;
}

console.log(HeapSort([1, 6, 7, 3, 4, 9, 2]));
